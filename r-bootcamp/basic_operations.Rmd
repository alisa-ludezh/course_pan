---
title: "Базовые операции с таблицами, векторами и списками в R"
date: 2017-09-07
output: 
  html_document: 
    toc: true
    toc_float: true
---

# Введение

В этом блокноте показаны наиболее необходимые приемы обработки данных в R. Поясняется работа с базовыми типами данных R - векторами, списками и таблицами данных, а также загрузка данных из Excel. 


```{r Подключение пакетов, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl) # считывание данных в формате Excel
library(stringr) # операции со строками
```

Если у вас не ставится пакет `tidyverse`, то для работы с этим блокнотом потребуется установить и загрузить пакеты: `ggplot2`, `dplyr`, `readxl`, `stringr`.


# Как загрузить данные из Excel

Для загрузки данных в форматах `xlsx` и `xls` в R используется пакет `readxl` (входит в `tidyverse`). Поскольку в Excel поддерживается разделение данных по типам, обычно возникает меньше проблем при загрузке, чем с текстовыми файлами. Желательно, чтобы в Excel на листе, откуда предполагается читать данные, содержалась только таблица данных, начиная с первой строки. 

![Правильная структура рабочего листа](pics/excel.png)


При необходимости вы можете выбрать нужный лист и диапазон для чтения - см `?read_excel()`

```{r Чтение данных из Excel}
hotdogs <- read_excel('data/hotdogs.xlsx', sheet = 'data')
```


Загруженные данные помещены в переменную `hotdogs`. Данные - это результаты лабораторного анализа хот-догов с разным типом начинки: содержание натрия (`Sodium`) и пищевая ценность (`Calories`).

# Предварительное знакомство с данными

Мы можем проконтролировать результат загрузки, выведя небольшую часть данных в начале таблицы с помощью функции `head()`. При необходимости можно посмотреть также конец таблицы с помощью `tail()`, или всю таблицу целиком - с помощью `View()`. Вы можете вместо открыть таблицу для просмотра, используя интерфейс RStudio. 
Мы можем получить информацию о загруженных данных следующим образом:

```{r Предварительный просмотр данных таблицы}
head(hotdogs, n = 5) # посмотрим первые 5 строк
```

Также можно изучить структуру таблицы с помощью функции `str()`. Эта функция позволяет видеть структуру любого объекта в R.

```{r Структура таблицы}
str(hotdogs)
```

При работе с данными полезно знать их размерность. Для этого можно использовать функцию `dim()`:

```{r Количество строк и столбцов в таблице}
dim(hotdogs)
```

Еще одна полезная функция - `names()`. Эта функция позволяет вывести имена столбцов таблицы.

```{r Просмотр имен столбцов}
names(hotdogs)
```

С помощью функции `names()` можно не только посмотреть, но и изменить имена столбцов таблицы. Например, мы можем преобразовать все имена к нижнему регистру:

```{r Переименование столбцов}

names(hotdogs) <- str_to_lower(names(hotdogs))

head(hotdogs)
```

После загрузки данных всегда следует смотреть сводку по всем столбцам. Целью этой операции является выявление проблем в данных - выбросов, некорректных значений и пропусков. Для просмотра статистической сводки можно воспользоваться функцией `summary()`.

```{r Просмотр статистической сводки по данным}
summary(hotdogs)
```

В этом наборе данных мы видим, что имеются по 2 пропущенных значения в каждом числовом столбце. 

К сожалению, `summary()` не выводит информацию о пропущенных значениях в текстовых переменных.

Размах переменной `sodium` (содержание натрия) в почти в 4 раза выше, чем размах переменной `calories`. Распределение этой переменной имеет небольшую асимметрию, т.к. среднее смещено вправо относительно медианы. 

# Ивзлечение данных из таблицы

Наиболее востребованными операциями с таблицей данных являются извлечение столбца, вычисление нового столбца и отбор данных.


## Извлечение столбца из таблицы и векторизованные операции

Если для анализа необходимы данные одного из столбцов таблицы - можно обратиться к столбцу, указав его после имени таблицы через `$`:

```{r Извлечение столбца}

# Калорийность в исходных единицах (ккал):
hotdogs$calories

```

В результате извлечения столбца таблицы получается другой базовый тип данных R - **вектор**. Все операции с вектором выполняются одновременно для всех его элементов (такие операции называются **векторизованными**). Например, можем пересчитать пищевую ценность из ккал в кДж:

```{r Пример операции с вектором}
# Калорийность в кДж
round(hotdogs$calories * 4.184)

```

Мы можем добавлять в таблицу новые столбцы, также используя запись с `$`. В качестве примера вычислим относительное содержание натрия в хот-догах. К сожалению, в таблице нет массы, поэтому мы не сможем вычислить процентное содержание. Однако в качестве показателя размера хот-дога можем воспользоваться калорийностью. Более калорийные хот-доги должны быть более тяжелыми.

## Вычисление нового столбца

```{r Вычисление нового столбца}
# Соотношение Na и калорийности:

hotdogs$sodium_ratio = hotdogs$sodium / hotdogs$calories

head(hotdogs)
```


## Отбор строк

Для отбора строк можно воспользоваться встроенной функцией `subset()`. В дальнейшем мы покажем более удобную функцию `filter()` из пакета `dplyr()`.

В качестве примера, отберем и сохраним в новую переменную очень соленые хот-доги с курицей и высоким соотношением Na/калорийность.

```{r Отбор строк с помощью subset}
high_sodium <- subset(hotdogs, sodium_ratio > 4 & type == 'Poultry')
high_sodium
```

Про доступные условия отбора можно почитать в книге [R for Data Science](http://r4ds.had.co.nz/transform.html#comparisons).

Обратите, пожалуйста, внимание, что проверка на равенство записывается так: `x == y` (двойной знак равенства).

Если вам необходимо отбирать по равенству действительные числа, используйте функцию: `near(x, y)` вместо `x == y`.

Несколько условий отбора можно комбинировать с помощью логических союзов И, ИЛИ, НЕ и т.п. На рисунке показаны доступные в R логические операции. 

![Логические операции](http://r4ds.had.co.nz/diagrams/transform-logical.png)



## Отбор столбцов

Иногда необходимо отобрать несколько столбцов из большой таблицы. Позднее мы покажем, как это сделать с помощью dplyr. Но полезно также знать, как эта операция выполняется стандартными средствами R.

Таблица в R - это двухмерный объект, состоящий из строк и столбцов. Чтобы извлечь часть таблицы, достаточно указать нужные индексы или имена строк и столбцов в `[]`. Первый индекс соответствует строкам, второй - столбцам. Если индекс не пропущен, то выводятся все строки/столбцы. Нумерация в R начинается с 1.

```{r Отбор столбцов по номеру}

high_sodium[ , c(1, 4)]

```

Здесь `c()` - функция для создания вектора с номерами нужных столбцов.

Добавив `-`, можно извлечь все кроме указанных столбцов.

```{r Исключение столбцов}

high_sodium[ , -c(2, 3)]

```


Поскольку структура данных может со временем меняться, очень опасно отбирать элементы таблицы по номерам. Если нумерация поменяется, то ваш скрипт будет обрабатывать неправильные данные. Это может незаметно исказить результаты анализа. Лучше всегда использовать имена.

```{r Отбор столбцов по имени}

high_sodium[ , c('type', 'sodium_ratio')]

```


# Пропущенные значения

Пропущенные значения (NA) вызывают массу проблем при анализе. Любая операция с пропущенным (неизвестным) значением имеет неизвестный результат. Пропущенные значения приходится либо отфильтровывать, теряя данные, либо заполнять на основе известных данных.

```{r Пробуем посчитать среднее содержание натрия}

mean(hotdogs$sodium)

```

В R аналитику требуется в явном виде указать свое решение относительно обработки NA, чтобы предотвратить случайную ошибку. Для этого во многих статистических функциях доступен аргумент `na.rm = ...`, позволяющий отбросить пропущенные значения.

```{r Считаем среднее без учета пропущенных значений}

mean(hotdogs$sodium, na.rm = TRUE)

```


Поскольку результат любой операции с `NA` - это `NA`, нельзя искать пропущенные значения с помощью сравнения по `==`. Вместо этого нужно использовать функцию: `is.na()`.

Найдем пропуски в данных:

```{r Поиск пропущенных значений}

subset(hotdogs, is.na(sodium) | is.na(calories)) # можно не указывать sodium_ratio, т.к. он будет пустым если в любом из этих столбцов было NA
```

Создадим новую таблицу с очищенными от пропусков данными:

```{r Очистка от пропущенных значений}

hotdogs_complete <- 
  subset(hotdogs, !is.na(sodium) & !is.na(calories))

# Размер исходной таблицы
dim(hotdogs)

# Размер очищенной таблицы
dim(hotdogs_complete)

```

Аналогичного эффекта можно быстрее добиться с помощью встроенной функции `complete.cases()`, которая определяет, какие  строки таблицы полностью заполнены.

```{r Что выдает complete.cases}
complete.cases(hotdogs)
```

Результат функции можно использовать для фильтрации нужных строк таблицы c помощью `subset()`.

```{r Очистка от пропусков с помощью complete.cases}

hotdogs_complete2 <- 
  subset(hotdogs, complete.cases(hotdogs))

dim(hotdogs_complete2)

```

Нужно с осторожностью использовать автоматическую фильтрацию пропусков, поскольку эта операция может привести к большой потере данных и исказить результаты анализа.

# Обработка выбросов

В данных часто встречаются аномальные значения, вызванные ошибками ввода и другими причинами. В некоторых случаях полезно отфильтровать их или заменить на более типичные значения. Здесь в качестве примера мы заменим по 2.5% наибольших и наименьших значений содержания натрия на соответствующую границу (квантиль.)


```{r Замена выбросов}
min_sodium <- quantile(hotdogs_complete$sodium, 
                       probs = 0.025, 
                       na.rm = TRUE)
min_sodium

max_sodium <- quantile(hotdogs_complete$sodium, 
                       probs = 0.975, 
                       na.rm = TRUE)
max_sodium

hotdogs_complete$sodium_fixed <- 
  ifelse(hotdogs_complete$sodium > max_sodium, max_sodium, 
         ifelse(hotdogs_complete$sodium < min_sodium, min_sodium,
                hotdogs_complete$sodium))  
```

Сравним исходную и очищенную переменные:

```{r Сравнение размахов исходной и очищенной переменной}
# Исходная переменная
summary(hotdogs_complete$sodium)

# Очищенная переменная
summary(hotdogs_complete$sodium_fixed)

```

## Задание: очистка от выбросов

Постройте гистограмму распределения переменной `calories` в наборе данных `hotdogs_complete`. Есть ли подозрительные выбросы в данных? Если есть - напишите код, заменяющий выбросы на медианное значение этой переменной.

```{r Визуализация распределения и замена выбросов на медианное значение}
#ggplot(data = hotdogs_complete) +
#  geom____(mapping = ())

```

## Задание: заполнение пропущенных значений

Попробуйте восстановить пропущенные значения в таблице `hotdogs`, заменив их на наиболее типичные (средние или медиану) по соответствующей переменной. Результат сохраните в столбцы `<имя переменной>_fixed` в таблице `hotdogs`.

```{r Восстановление пропусков}

```


# Работа с векторами

## Создание вектора вручную

В некоторых случаях векторы приходится вводить вручную. Например, некоторые функции требуют вектор в качестве значения аргумента. Чтобы создать вектор, используйте функцию `c()`:

```{r Создание вектора вручную}

my_probs <- c(0.1, 0.5, 0.9)
my_probs

```

Мы сохранили вектор в переменную `my_probs` и теперь можем использовать ее в расчетах. Например, в качестве аргумента для функции расчета квантилей:

```{r Расчет нескольких квантилей }

quantile(hotdogs_complete$sodium_ratio, 
         probs = my_probs, 
         na.rm = TRUE)

```

В данном случае, конечно, можно было и сразу перечислить нужные вероятности при вызове функции `quantile()`:

```{r Можно создавать вектор по месту использования}
quantile(hotdogs_complete$sodium_ratio, 
         probs = c(0.1, 0.5, 0.9), 
         na.rm = TRUE)

```

## Извлечение элемента вектора

Извлечь нужные элементы вектора можно по их индексу. Вспомним, что R нумерует элементы начиная с 1.

```{r Извлечение элемента вектора по индексу}
my_probs[1]
my_probs[c(1, 3)]
```


## Использование последовательностей

В некоторых случаях требуется создать вектор, представляющий собой последовательность значений с одинаковым шагом. Для этого можно воспользоваться функцией `seq()`.

```{r Последовательность}

x_breaks <- seq(0, 200, by = 20)
y_breaks <- seq(0, 900, by = 50)

x_breaks


ggplot(data = hotdogs_complete,
       mapping = aes(x = calories, y = sodium)) +
  geom_point() +
  scale_x_continuous(breaks = x_breaks) +
  scale_y_continuous(breaks = y_breaks)

```


Для последовательностей с единичным шагом можно использовать краткую запись:

```{r Последовательность с единичным шагом}

5:10

```


## Объединение векторов в таблицу данных

В некоторых случаях требуется объединить несколько векторов и создать из них таблицу данных. Например, функция `ggplot()` может работать только с табличными данными.

В качестве примера создадим два случайных вектора и сделаем из них таблицу данных. Мы будем использовать современный тип таблиц - `tibble`. Классический `data.frame` создается аналогичным образом.

```{r Создание таблицы из векторов}

set.seed(12345) # инициализируем генератор случайных чисел для воспроизводимости
rx <- rnorm(n = 10000, mean = 100, sd = 20)
ry <- rnorm(n = 10000, mean = 100, sd = 20)

my_table <- tibble(x = rx, y = ry) # <имя столбца> = <имя вектора>

head(my_table)

ggplot(data = my_table, aes(x, y)) +
  geom_point(alpha = 0.1, color = 'lightskyblue') +
  coord_fixed() # одинаковый масштаб по x и y

```

# Работа со списками

Векторы в R могут содержать значения любого типа, однако этот тип должен быть одинаковым у всех элементов вектора. Для обработки разнотипных элементов используются **списки** (list). Элементами списка могут быть любые объекты, в т.ч. векторы и другие списки. Векторизованные операции со списками напрямую не поддерживаются, однако их можно обрабатывать с помощью функций `*apply()` и функций из пакета `purrr`.

## Создание списка

Для создания списков используется функция `list()`.

```{r Создание списка}

inner_list <- list(11, 'A', TRUE)
inner_list

```

## Извлечение элементов из списка

При извлечении элемента списка `[]` возвращает единичный список, содержащий элемент по указанному индексу, а `[[]]` - сам этот элемент.

```{r Извлечение элемента списка}
inner_list[2]

inner_list[[2]]
```


![Иллюстрация работы с элементами списка](pics/lists.png)


## Именованные списки

В R у элементов векторов и списков могут быть имена. Эти имена можно вместо индексов использовать для извлечения элементов.

```{r Именованный список}

named_list <- list(first = inner_list, second = 1:5, third = pi)
named_list

```

Структуру списка можно изучить при помощи функций `names()` и `str()`.

Какие элементы есть в списке? 

```{r Просмотр имен элементов}
names(named_list)
```

Развернутая структура списка.

```{r Развернутая структура}
str(named_list)
```



```{r Извлечение элемента списка по имени}

named_list[['third']]

named_list$third
```

С помощью именованных списков можно передавать аргументы для функций.

```{r Аргументы функции в виде списка}

my_args <- list(from = 1, to = 10, by = 2)
seq(my_args)

```


## Объекты R - это списки

Умение работать со списками важно, поскольку объекты в R - например, модели, графики ggplot2, таблицы данных - хранятся в виде списков.

В качестве примера построим модель зависимости содержания натрия от калорийности и исследуем ее тип и структуру.

```{r Построение линейной модели}

# Полученная модель сохраняется в виде списка
m_sodium <- lm(sodium ~ calories, data = hotdogs_complete)

# Какие имена доступны
names(m_sodium)

```

Зная имена элементов объекта, можно их извлечь и использовать в расчетах.

```{r Извлечение коэффициентов модели}
# Получим вектор коэффициентов модели
m_sodium$coefficients

```

Добавим на диаграмму рассеяния линию тренда с использованием полученных коэффициентов.

```{r Добавление тренда с найденными коэффициентами}
ggplot(data = hotdogs_complete,
       mapping = aes(x = calories, y = sodium)) +
  geom_point() +
  geom_abline(intercept = m_sodium$coefficients['(Intercept)'],
              slope = m_sodium$coefficients['calories'],
              color = 'red')

```

Подробно изучить структуру объекта можно с  помощью функции `str()` или панели `Global Environment` в RStudio.