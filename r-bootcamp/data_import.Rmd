---
title: "Импорт данных в R с помощью readr"
date: '12 октября 2017 г '
output: 
  html_document: 
    toc: true
    toc_float: true
---


```{r Загрузка библиотек, warning=FALSE, message=FALSE}
library(tidyverse)
library(hms) #для работы временными данными
```

# Основные функции `readr`

В этом блокноте мы рассмотрим возможности пакета `readr`, обеспечивающего импорт данных в R. Пакет `readr` для является частью  `tidyverse`, большинство функций `readr` связаны с превращением плоских файлов в датафреймы:

* `read_csv()` читает файлы с разделителем запятой, `read_csv2()` читает файлы с разделителем точка с запятой, `read_tsv()`читает файлы с табуляцией как разделителем, а `read_delim()` читает файлы с любым разделителем.

* `read_fwf()` читает файлы с фиксированной шириной. Вы можете определить поля либо по их ширине с помощью `fwf_widths()` или по их позиции с помощью `fwf_positions()`.

* `read_table()` читает обычную разновидность файлов фиксированной ширины, где колонки разделены пробелом.

* `read_log()` читает системные журналы. Также есть [webreadr](https://github.com/Ironholds/webreadr), построенный на основе `read_log()` и предоставляющий еще больше полезных инструментов.

Все эти функции имеют похожий синтаксис. Разберем их работу на примере `read_csv()`.

#Основные параметры функции `read_csv()`

Первый аргумент в `read_csv()` самый важный: это путь к файлу, который нужно прочитать.

```{r Импорт данных из файла csv, message = TRUE}
mm <- read_csv("data/MissingMigrantsProject.csv")
```

Когда вы запускаете `read_csv()`, он выводит спецификацию колонок, которая сообщает имя и тип каждой колонки.

Вы также можете создать временный csv-файл. Это удобно для экспериментов с `readr` и создания воспроизводимых примеров, чтобы делиться с другими:

```{r Чтение временного файла}
read_csv("a,b,c
1,2,3
4,5,6")
```

В обоих случаях `read_csv()` использует первую строку данных как имена колонок. В некоторых случаях бывает необходимо поменять такое поведение:

1.  В начале файла может быть несколько строк с описанием данных. Вы можете использовать `skip = n`, чтобы пропустить первые `n` строк; или использовать `comment = "#"`, чтобы удалить все строки, начинающиеся с `#`.
    
```{r Пропуск строк}
read_csv("Первая строка с описанием данных
      Вторая строка с описанием данных
      x,y,z
      1,2,3", skip = 2)
    
read_csv("#Комментарий, который нужно пропустить
      x,y,z
      1,2,3", comment = "#")
```
    
2.  В данных может не быть названий колонок. В этом случае вы можете использовать `col_names = FALSE`, чтобы сказать `read_csv()` не считать первый ряд заголовками, а вместо этого обозначить их последовательно от `X1` до `Xn`:
    
```{r Автоматическое именование столбцов}
read_csv("1,2,3\n4,5,6", col_names = FALSE) # "\n" - удобное сокращение для добавления новой строки
```
    
Также вы можете задать для `col_names` символьный вектор, который будет использоваться как названия колонок:
    
```{r Задание вектора названий колонок}
read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))
```

Параметр `na` определяет значения, которые используются для обозначения пропусков в вашем файле. Например, пропуски обозначаются как ".":

```{r Задание символов пропущенных значений}
read_csv("a,b,c\n1,2,.", na = ".")
```


## Упражнения 1. Импорт данных

### Упражнение 1.1

Напишите код, чтобы прочитать файл `data/ambulance.csv`.
![Файл `ambulance.csv`](pics/ambulance.png)

```{r Упражнение 1.1}
#Напишите ваш код здесь
```

##Упражнение 1.2

Иногда строки в CSV-файле содержат запятые. Чтобы они не вызывали проблем, их нужно заключать в кавычки, как `"` или `'`. Обычно `read_csv()` считает, что кавычки выглядят так `"`, и если вы хотите поменять их, то нужно использовать `read_delim()`. Напишите код, чтобы прочитать следующий текст как датафрейм.
    
```{r Упражнение 1.2, eval = FALSE}
"x,y\n1,'a,b'"
```

##Упражнение 1.3    

Определите, что не так с каждым из следующих CSV-файлов. Как можно исправить код?
    
```{r Упражнение 1.3, eval = FALSE}
read_csv("a,b\n1,2,3\n4,5,6")
read_csv("a,b,c\n1,2\n1,2,3,4")
read_csv("a,b\n\"1")
read_csv("a,b\n1,2\na,b")
read_csv("a;b\n1;3")
```

#Преобразование типов данных

Часто при импорте файлов типы данных распознаются не так, как нужно. В этом случае необходимы преобразования типов, которые можно производить с помощью функций `parse_*()`. Эти функции преобразуют вектор символьных значений в вектор логических значений, целых чисел или дат:

```{r Функции parse_*()}
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))
```

Аргументы функций `parse_*()`:

- символьный вектор, тип которого надо изменить;  
- `na`, который определяет значения, обозначающие пропущенные.  

```{r Преобразование в тип integer}
parse_integer(c("1", "231", ".", "456"), na = ".")
```

Если изменение типа не получается, вы получите предупреждение:

```{r Преобразование в тип integer с предупреждением}
x <- parse_integer(c("123", "345", "abc", "123.45"))
```

Если есть много ошибок при измененении типа, можно использовать `problems()`, чтобы получить их полный набор. Эта функция возвращает tibble, с которым вы можете работать в `dplyr`.

```{r Просмотр проблем преобразования типов}
problems(x)
```

Основные функции преобразования типов данных:

1.  `parse_logical()` и `parse_integer()` возвращают логические и целые значения соответственно.
    
1.  `parse_double()` и `parse_number()` преобразуют в числовые значения.

1.  `parse_character()` преобразует символьные с учетом кодировки.

1.  `parse_factor()` создает факторы, структуру данных, которую R использует для представления категориальных переменных с фиксированным числом значений.

1.  `parse_datetime()`, `parse_date()` и `parse_time()` позволяют устанавливать тип для разных вариантов даты и времени.


## Преобразование числовых данных

Есть три проблемы, которые усложняют преобразование в числовой формат:

1. Люди пишут числа по-разному в разных частях мира.
   Например, некоторые страны используют `.` между целой и десятичной частью вещественного числа в то время, как другие используют `,`.
   
1. Рядом с числами часто есть другие знаки, которые добавляют контекст, как "$1000" или "10%".

1. Числа часто содержат разделители групп разрядов, чтобы улучшить читаемость, 
   как "1,000,000", и эти разделители групп разрядов различаются по всему миру.

Чтобы решить первую проблему, `readr` имеет аргумент `locale`, объект, который определяет настройки приведения к типу, различающиеся от места к месту. Для чисел наиболее важная настройка - знак разделителя десятичной части. Вы можете изменить значение по умолчанию `.`, настроив аргумент `decimal_mark`:

```{r Настройка разделителя десятичного разряда}
parse_double("1.23")
parse_double("1,23", locale = locale(decimal_mark = ","))
```

`parse_number()` решает вторую проблему: он игнорирует нечисловые знаки до и после числа. Это особенно удобно для валют и процентов, но также работает для извлечения чисел из текста.

```{r Игнорирование нечисловых знаков}
parse_number("$100")
parse_number("20%")
parse_number("It cost $123.45")
```

Последняя проблема решается комбинацией `parse_number()` и `locale`, так как `parse_number()` будет игнорировать разделители групп разрядов:

```{r Настройка разделителей групп разрядов}
# Используется в Америке
parse_number("$123,456,789")

# Используется во многих странах Европы
parse_number("123.456.789", locale = locale(grouping_mark = "."))

# Используется в Швейцарии
parse_number("123'456'789", locale = locale(grouping_mark = "'"))

# Используется в России
parse_number("123 456 789 руб.", locale = locale(grouping_mark = " "))
```

### Преобразование строковых данных

Компьютеры представляют символы в виде шестнадцатеричных чисел. В R мы можем получить "сырое" представление строки, используя `charToRaw()`:

```{r}
charToRaw("Логистика")
```

Каждое шестнадцатеричное число представляет байт информации: `cb` - это "Л", `ee` - это "о" и так далее. Переход от шестнадцатеричного числа к знаку называется кодированием, и в этом случае кодировка называется ASCII. ASCII хорошо представляет английские буквы, потому что это *Американская* Стандартная Кодировка для Информационного Обмена.

К счастью, сегодня есть единый стандарт UTF-8, который поддерживается почти везде. UTF-8 может закодировать почти любой символ, используемый человеком, а также множество дополнительных символов.

`readr` использует UTF-8 везде: он предполагает, что ваши данные в кодировке UTF-8 при чтении и всегда использует ее при записи. Это хорошо по умолчанию, но не будет работать для данных из старых систем, которые не понимают UTF-8. Если это произойдет с вами, ваши строки будут выглядеть странно при выводе. Например:

```{r Проблемы с кодировкой}
x1 <- "El Ni\xf1o was particularly bad this year"
x2 <- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"

x1
x2
```

Для решения проблемы надо определить кодировку в `parse_character()`:

```{r Настройка кодировки}
parse_character(x1, locale = locale(encoding = "Latin1"))
parse_character(x2, locale = locale(encoding = "Shift-JIS"))
```

Для автоматического определения кодировки в `readr` есть функция `guess_encoding()`. Она не гарантирует надежность и лучше работает на большом количестве текста (не как здесь).

```{r Определение кодировки}
guess_encoding(charToRaw(x1))
guess_encoding(charToRaw(x2))
```

Первый аргумент `guess_encoding()` может быть либо путем к файлу, или, как в данном случае, сырым вектором.

Подробнее о кодировках можно прочитать [здесь](http://kunststube.net/encoding/).

##Преобразование факторов

R использует факторы для представления категориальных переменных, которые имеют известное множество возможных значений. Если дать на вход `parse_factor()` вектор известных значений `levels`, при появлении неожиданных значений будет генерироваться предупреждение:

```{r Преобразование факторов}
fruit <- c("apple", "banana")
parse_factor(c("apple", "banana", "bananana"), levels = fruit)
```

Но если у вас много неверно введенных данных, часто проще оставить их как символьные вектора и произвести очистку другими средствами.

##Преобразование дат и времени

Основные функции преобразования в типы `datetime`, `date` и `time`:

*   `parse_datetime()` ожидает стандарт даты-времени ISO8601. [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) - это международный стандарт, в котором компоненты расположены от большего к меньшему: год, месяц, день, час, минута, секунда.
    
```{r Преобразование в тип datetime}
parse_datetime("2010-10-01T2010")
# Если время не указано, то по умолчанию будет установлено 00:00:00
parse_datetime("20101010")
```
    
*   `parse_date()` ожидает на вход четырехзначный год, `-` или `/`, месяц, `-` или `/`, затем день:
    
```{r Преобразование в тип date}
parse_date("2010-10-01")
```

*   `parse_time()` ожидает на вход часы, `:`, минуты и опционально `:` секунды и определитель am/pm:
  
```{r Преобразование в тип time}
parse_time("01:10 am")
parse_time("20:10:01")
```
    
Если настройки по умолчанию не подходят для ваших данных, вы можете настроить свой `format`, составленный из следующих частей:

Год
: `%Y` 4 знака. 
: `%y` 2 знака; 00-69 -> 2000-2069, 70-99 -> 1970-1999.

Месяц
: `%m` 2 знака.
: `%b` сокращенное название, как "Jan".
: `%B` полное название, "January".

День
: `%d` 2 знака.
: `%e` возможен пробел впереди.

Время
: `%H` 0-23 часа.
: `%I` 0-12, нужно использовать с `%p`.
: `%p` индикатор AM/PM.
: `%M` минуты.
: `%S` целые секунды.
: `%OS` вещественные секунды. 
: `%Z` часовой пояс, например, `America/Chicago`. 
: `%z` отступ от Всемирного времени UTC, например, `+0800`. 

Нецифровые
: `%.` пропускает один нецифровой символ.
: `%*` пропускает любое количество нецифровых символов.

Лучший способ понять правильный формат - составить несколько примеров в виде символьного вектора и проверить с помощью нужной функции. Например:

```{r Варианты формата дат}
parse_date("01/02/15", "%m/%d/%y")
parse_date("01/02/15", "%d/%m/%y")
parse_date("01/02/15", "%y/%m/%d")
```

Если вы используете `%b` или `%B` с не англоязычными названиями месяцев, необходимо настроить аргумент  `lang` в функции `locale()`. Посмотреть список встроенных языков можно с помощью `date_names_langs()`.

```{r Настройка локали}
parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))
```

##Упражнение 2. Преобразование типов

Напишите код, чтобы привести к нужному типу следующие даты и время:
    
```{r Упражнения 2}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14"
t1 <- "1705"
t2 <- "11:15:10.12 PM"

#Напишите ваш код здесь
```

#Импорт других типов данных

Чтобы импортировать другие типы данных в R, можно использовать пакеты `tidyverse`:

* `haven` читает файлы SPSS, Stata и SAS.

* `readxl` читает excel-файлы (как `.xls`, так и `.xlsx`).

* `DBI`, вместе со специальным интерфейсом баз данных (например, `RMySQL`, `RSQLite`, `RPostgreSQL` и т.д.) позволяет вам запускать запросы SQL в базу данных и возвращать дата фрейм.

Для иерархических данных используйте пакет `jsonlite` (от Jeroen Ooms) для `json` и пакет `xml2` для `XML`.

Для других типов файлов, попробуйте [R data import/export manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html) и пакет [`rio`](https://github.com/leeper/rio).

